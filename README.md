# dispatch
A **DI**screte **S**ignal **P**rocessing library disp**ATCH**er

dispatch is a cross-platform environment and API for simulating discrete-time signal-processing algorithms, with convenient interfaces to several simulation codes. It can be thought of as a code/text-based SimulinkÂ®-like environment, restricted to discrete-time. It was developed for control system design in conjunction with wind turbine aeroelastic simulation software, but could easily be applied to other signal processing problems and other time-domain simulation software in a broad range of fields.

## Features
- cross-platform build system based on [cmake](https://cmake.org/) and [cpm.cmake](https://github.com/cpm-cmake/CPM.cmake) or [fpm](https://fpm.fortran-lang.org/)
- interfaces to the following wind turbine simulation software: Bladed, FAST, Flex5, HawC2, and QBlade
- a manager (/prj/dispatch) that handles the initialization/ termination and sampling of various signal processing algorithms at different rates, and resolves signal connections both between signal processors, and between the dispatch environment and the simulator.
- general-purpose signal processing libraries
	- infinite impulse response filters (/prj/iir_filters): implementation of arbitrary continuous-time transfer functions as discrete-time second-order-sections
	- extended Kalman filter (/prj/state_estimation): performs state estimation on a set of linear approximations to a nonlinear model
	- pure delay (/prj/delay): delays a signal by a requested number of sample periods
	- n-ary functions (/prj/n_ary_function): evaluates multiple-input, single-output functions on input signals. Implemented functions are +, -, \*, %, min, max.
	- soft clipper (/prj/soft_clipper): a cubic nonlinearity to smoothly limit the range of a signal (https://ccrma.stanford.edu/~jos/pasp/Soft_Clipping.html)
	- monitor (/prj/monitor): generates a 0/1 signal based on a condition evaluated on its input
	- signal generator (/prj/signal_generator): generates signals with various options to add to input, add to a held input, or trigger signal generation based on another signal value. Implemented signal waveforms are: constant, ramp, sinusoid, square wave, rectangular wave, triangular wave, Gaussian noise, uniform noise, and pseudo-random bit sequences.
	- signal renamer (/prj/signal_renamer): generates a renamed copy of a signal
- wind-turbine-specific signal processing libraries
	- rosco controller (/prj/rosco_controller): a dispatch implementation of the [ROSCO wind turbine controller](https://github.com/NREL/ROSCO)
- utilities
	- a program for timing execution of various dispatch configurations (/prj/timing_rig)

dispatch and the accompanying libraries have been tested on Windows and Linux platforms, using the Intel Fortran compiler. C/C++ libraries have also been developed and tested, but are not currently part of the project. Dispatch includes boilerplate/ template code for:
- implementing interfaces to simulation software
- implementing the dispatch API for interfacing signal processing code with the dispatch manager
- reading data from toml and hdf5 files
- handling and reporting error conditions

## Architecture

dispatch consists of an interface layer, a manager, and any number of signal processing libraries. The interface connects the dispatch environment - run by the manager - to simulation software. The manager loads the signal processing libraries specified in a toml configuration file, and passes parameters to the libraries (also specified in the toml file, either as toml themselves, or as a separate input file). Each library tells the manager its required sampling period, offers output signals that can be consumed by other libraries, and requests input signals as its input. The manager connects the inputs and outputs of the libraries based on signal names, i.e. if library A offers a signal named 'signal_a', and library B requests a signal named 'signal_a', then the value of 'signal_a' generated by library A will be passed as input to library B. Each time the simulation software calls the dispatch manager via the interface, the manager determines which of the signal processing libraries are to be called at that time, calls them in sequence, and passes the required signals from the simulator, between the libraries, and back to the simulator.

## Contributing

If you find this framework useful, please feel free to share it, improve upon it, or add functionality as you see fit. If you would like your changes added to the public repository, please submit a pull request. If there is a feature you need, but do not have the resources to build, please get in touch or open an issue for the community to discuss. If you discover any bugs, please flag them as an issue, or let me know. If dispatch looks useful to you, but you're not sure how to get started with it, please get in touch, and I can try to help - your questions will help me write better documentation, so I appreciate any and all.

Some of the features I would like to implement, but haven't yet gotten around to are:
- implementation of standard filter forms such as Bessel, Butterworth, Chebyshev, Elliptical, and Resonant. These can all be implemented already as transfer functions in /prj/iir_filters, but it would be nice to have higher-level constructors. This is essentially an exercise in translating code from [scipy.signal](https://docs.scipy.org/doc/scipy/reference/signal.html).
- some general-purpose controller libraries:
	- PID with various anti-windup implementations
	- LQG, adaptive, LPV, ...
- implementation and testing of interfaces to other simulation software.
- experiment with passing function pointers as signals (this would enable a callback-type feature, allowing one signal processing library to call a function defined in another signal processing library).
- a library of examples. Some of the problems I have found dispatch useful for are system identification (using signal generators to inject perturbation signals into a system), filtering, state estimation, and model predictive control. I'd like to build up a set of general examples of some of these things to make them easier for others.
- more documentation. A lot of the code contains some documentation, but more work is always needed.