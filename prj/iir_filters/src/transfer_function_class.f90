module transfer_function_class
  use dispatch_types, only: wp
  use zpk_class, only: zpk_t
  use polyroots_module, only: rpoly, polyroots, newton_root_polish
  use error_handling, only: error_t, fail, wrap_error
  use extf, only: itoa
  implicit none
  
  type :: transfer_function_t
    real(8), allocatable :: num(:), den(:)
    class(error_t), allocatable :: error
  contains
    procedure :: tozpk
    procedure :: normalize
  end type
  
  interface transfer_function_t
    procedure :: constructor
  end interface

  contains
  
  function constructor(num, den) result(this)
  real(wp), intent(in) :: num(:), den(:)
  type(transfer_function_t) :: this
  integer :: i
  allocate(this%num(size(num)), source=0.0_wp)
  allocate(this%den(size(den)), source=0.0_wp)
  do i = 1,size(num)
    this%num(i) = num(i)
  end do
  do i = 1,size(den)
    this%den(i) = den(i)
  end do
  end function
  
  subroutine tozpk(this, zpk, error)
    !Return zero, pole, gain (z, p, k) representation from a numerator,
    !denominator representation of a linear filter.
    !
    !This code is based on scipy's implementation of tf2zpk()
    !
    !Parameters
    !----------
    !b : array_like
    !    Numerator polynomial coefficients.
    !a : array_like
    !    Denominator polynomial coefficients.
    !
    !Returns
    !-------
    !z : ndarray
    !    Zeros of the transfer function.
    !p : ndarray
    !    Poles of the transfer function.
    !k : float
    !    System gain.
    !
    !Notes
    !-----
    !If some values of `b` are too close to 0, they are removed. In that case,
    !a BadCoefficients warning is emitted.
    !
    !The `b` and `a` arrays are interpreted as coefficients for positive,
    !descending powers of the transfer function variable. So the inputs
    !:math:`b = [b_0, b_1, ..., b_M]` and :math:`a =[a_0, a_1, ..., a_N]`
    !can represent an analog filter of the form:
    !
    !.. math::
    !
    !    H(s) = \frac
    !    {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
    !    {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}
    !
    !or a discrete-time filter of the form:
    !
    !.. math::
    !
    !    H(z) = \frac
    !    {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
    !    {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}
    !
    !This "positive powers" form is found more commonly in controls
    !engineering. If `M` and `N` are equal (which is true for all filters
    !generated by the bilinear transform), then this happens to be equivalent
    !to the "negative powers" discrete-time form preferred in DSP:
    !
    !.. math::
    !
    !    H(z) = \frac
    !    {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
    !    {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}
    !
    !Although this is true for common filters, remember that this is not true
    !in the general case. If `M` and `N` are not equal, the discrete-time
    !transfer function coefficients must first be converted to the "positive
    !powers" form before finding the poles and zeros.
    !
    !Examples
    !--------
    !Find the zeroes, poles and gain of 
    !a filter with the transfer function
    !
    !.. math::
    !
    !    H(s) = \frac{3s^2}{s^2 + 5s + 13}
    !    
    !>>> from scipy.signal import tf2zpk
    !>>> tf2zpk([3, 0, 0], [1, 5, 13])
    !(   array([ 0.               ,  0.              ]), 
    !    array([ -2.5+2.59807621j ,  -2.5-2.59807621j]), 
    !    3.0)
    !
    class(transfer_function_t),  intent(inout) :: this
    type(zpk_t),                 intent(  out) :: zpk
    class(error_t), allocatable, intent(  out) :: error
    integer :: stat = 0, degree, i
    real(wp), allocatable :: zr(:), zi(:), pr(:), pi(:)
    
    try: block
      call normalize(this, error)
      if (allocated(error)) then
        call wrap_error(error, "tozpk()'s call to normalize failed")
        exit try
      end if
      this%num = this%num / this%den(1)
      this%den = this%den / this%den(1)
      zpk%k = this%num(1)
      this%num = this%num / this%num(1)
      degree = size(this%num) - 1
      allocate(zpk%z(max(1, degree)))
      allocate(zr(max(1, degree)))
      allocate(zi(max(1, degree)))
      ! get numerator roots (zeros)
      call polyroots(degree, this%num, zr, zi, stat)
      if (stat .ne. 0) then
        error = fail("numerator root-finding (zeros) returned status: " // itoa(stat))
        exit try
      end if
      ! polish the zero values if possible
      do i = 1,degree
        call newton_root_polish(degree, this%num, zr(i), zi(i), 0.0d0, 0.0d0, 100, stat)
        ! don't check stat: if the root can't be polished in 100 iterations, just leave it as-is
      end do
      zpk%z = cmplx(zr, zi, kind=wp)
      degree = size(this%den) - 1
      allocate(zpk%p(max(1, degree)))
      allocate(pr(max(1, degree)))
      allocate(pi(max(1, degree)))
      ! get denominator roots (poles)
      call polyroots(degree, this%den, pr, pi, stat)
      if (stat .ne. 0) then
        error = fail("denominator root-finding (poles) returned status: " // itoa(stat))
        exit try
      end if
      ! polish the pole values if possible
      do i = 1,degree
        call newton_root_polish(degree, this%den, pr(i), pi(i), 0.0d0, 0.0d0, 100, stat)
        ! don't check stat: if the root can't be polished in 100 iterations, just leave it as-is
      end do
      zpk%p = cmplx(pr, pi, kind=wp)
      return
    end block try
  end subroutine
  
  subroutine normalize(this, error)
    !Normalize numerator/denominator of a continuous-time transfer function.
    !
    !This code is based on scipy's implementation of normalize()
    !
    !If values of `b` are too close to 0, they are removed. In that case, a
    !BadCoefficients warning is emitted.
    !
    !Parameters
    !----------
    !b: array_like
    !    Numerator of the transfer function. Can be a 2-D array to normalize
    !    multiple transfer functions.
    !a: array_like
    !    Denominator of the transfer function. At most 1-D.
    !
    !Returns
    !-------
    !num: array
    !    The numerator of the normalized transfer function. At least a 1-D
    !    array. A 2-D array if the input `num` is a 2-D array.
    !den: 1-D array
    !    The denominator of the normalized transfer function.
    !
    !Notes
    !-----
    !Coefficients for both the numerator and denominator should be specified in
    !descending exponent order (e.g., ``s^2 + 3s + 5`` would be represented as
    !``[1, 3, 5]``).
    !
    !Examples
    !--------
    !>>> from scipy.signal import normalize
    !
    !Normalize the coefficients of the transfer function
    !``(3*s^2 - 2*s + 5) / (2*s^2 + 3*s + 1)``:
    !
    !>>> b = [3, -2, 5]
    !>>> a = [2, 3, 1]
    !>>> normalize(b, a)
    !(array([ 1.5, -1. ,  2.5]), array([1. , 1.5, 0.5]))
    !
    !A warning is generated if, for example, the first coefficient of
    !`b` is 0.  In the following example, the result is as expected:
    !
    !>>> import warnings
    !>>> with warnings.catch_warnings(record=True) as w:
    !...     num, den = normalize([0, 3, 6], [2, -5, 4])
    !
    !>>> num
    !array([1.5, 3. ])
    !>>> den
    !array([ 1. , -2.5,  2. ])
    !
    !>>> print(w[0].message)
    !Badly conditioned filter coefficients (numerator): the results may be meaningless
    !
    class(transfer_function_t),  intent(inout) :: this
    class(error_t), allocatable, intent(  out) :: error
    integer :: i, n_leading_zeros
    real(wp), allocatable :: trimmed_num(:), trimmed_den(:)
    
    try: block
      if (all(abs(this%den) .le. epsilon(this%den(1)))) then
        error = fail("Denominator must have at least one nonzero element.")
        exit try
      end if

      ! count leading zeros in denominator
      n_leading_zeros = 0
      do while (n_leading_zeros .lt. size(this%den))
        if (abs(this%den(n_leading_zeros + 1)) .le. epsilon(this%den(1))) then
          n_leading_zeros = n_leading_zeros + 1
        else
          exit
        end if
      end do
      ! trim leading zeros from denominator
      if (n_leading_zeros .gt. 0) then
        allocate(trimmed_den(size(this%den) - n_leading_zeros), source = this%den((n_leading_zeros + 1):size(this%den)))
        call move_alloc(this%den, trimmed_den)
      end if

      ! Normalize transfer function
      this%num = this%num / this%den(1)
      this%den = this%den / this%den(1)

      ! count leading zeros in numerator
      n_leading_zeros = 0
      do while (n_leading_zeros .lt. size(this%num))
        if (abs(this%num(n_leading_zeros + 1)) .le. epsilon(this%num(1))) then
          n_leading_zeros = n_leading_zeros + 1
        else
          exit
        end if
      end do
      ! trim leading zeros from numerator
      if (n_leading_zeros .gt. 0) then
        allocate(trimmed_num(size(this%num) - n_leading_zeros), source = this%num((n_leading_zeros + 1):size(this%num)))
        call move_alloc(this%num, trimmed_num)
      end if
      return
    end block try
  end subroutine
end module